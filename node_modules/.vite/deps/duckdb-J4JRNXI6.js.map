{
  "version": 3,
  "sources": ["../../@observablehq/notebook-kit/dist/src/runtime/stdlib/duckdb.js"],
  "sourcesContent": ["import * as duckdb from \"npm:@duckdb/duckdb-wasm\";\n// Adapted from https://observablehq.com/@cmudig/duckdb-client\n// Copyright 2021 CMU Data Interaction Group\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n//    this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n//    this list of conditions and the following disclaimer in the documentation\n//    and/or other materials provided with the distribution.\n//\n// 3. Neither the name of the copyright holder nor the names of its contributors\n//    may be used to endorse or promote products derived from this software\n//    without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\nconst bundles = {\n    mvp: {\n        mainModule: \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/dist/duckdb-mvp.wasm\",\n        mainWorker: \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/dist/duckdb-browser-mvp.worker.js\"\n    },\n    eh: {\n        mainModule: \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/dist/duckdb-eh.wasm\",\n        mainWorker: \"https://cdn.jsdelivr.net/npm/@duckdb/duckdb-wasm@1.29.0/dist/duckdb-browser-eh.worker.js\"\n    }\n};\nconst bundle = duckdb.selectBundle(bundles);\nconst logger = new duckdb.ConsoleLogger(duckdb.LogLevel.WARNING);\n// let db;\n// let inserts = [];\n// const sources = new Map();\n// export function registerTable(name, source) {\n//   if (source == null) {\n//     sources.delete(name);\n//     db = DuckDBClient.of(); // drop existing tables and views before re-inserting\n//     inserts = Array.from(sources, (i) => db.then((db) => insertSource(db._db, ...i)));\n//   } else {\n//     sources.set(name, source);\n//     db ??= DuckDBClient.of(); // lazy instantiation\n//     inserts.push(db.then((db) => insertSource(db._db, name, source)));\n//   }\n// }\n// export async function sql(strings, ...args) {\n//   return (await getDefaultClient()).query(strings.join(\"?\"), args);\n// }\n// export async function getDefaultClient() {\n//   await Promise.all(inserts);\n//   return await (db ??= DuckDBClient.of());\n// }\nexport class DuckDBClient {\n    constructor(db) {\n        Object.defineProperties(this, {\n            _db: { value: db }\n        });\n    }\n    async queryStream(query, params) {\n        const connection = await this._db.connect();\n        let reader, batch;\n        try {\n            if (params?.length > 0) {\n                const statement = await connection.prepare(query);\n                reader = await statement.send(...params);\n            }\n            else {\n                reader = await connection.send(query);\n            }\n            batch = await reader.next();\n            if (batch.done)\n                throw new Error(\"missing first batch\");\n        }\n        catch (error) {\n            await connection.close();\n            throw error;\n        }\n        return {\n            schema: batch.value.schema,\n            async *readRows() {\n                try {\n                    while (!batch.done) {\n                        yield batch.value.toArray();\n                        batch = await reader.next();\n                    }\n                }\n                finally {\n                    await connection.close();\n                }\n            }\n        };\n    }\n    async query(query, params) {\n        const connection = await this._db.connect();\n        let table;\n        try {\n            if (params?.length > 0) {\n                const statement = await connection.prepare(query);\n                table = await statement.query(...params);\n            }\n            else {\n                table = await connection.query(query);\n            }\n        }\n        finally {\n            await connection.close();\n        }\n        return table;\n    }\n    async queryRow(query, params) {\n        const result = await this.queryStream(query, params);\n        const reader = result.readRows();\n        try {\n            const { done, value } = await reader.next();\n            return done || !value.length ? null : value[0];\n        }\n        finally {\n            await reader.return();\n        }\n    }\n    async sql(strings, ...args) {\n        return await this.query(strings.join(\"?\"), args);\n    }\n    queryTag(strings, ...params) {\n        return [strings.join(\"?\"), params];\n    }\n    escape(name) {\n        return `\"${name}\"`;\n    }\n    async describeTables() {\n        return Array.from(await this.query(\"SHOW TABLES\"), ({ name }) => ({ name }));\n    }\n    async describeColumns(options = {}) {\n        return Array.from(await this.query(`DESCRIBE ${this.escape(options.table)}`), ({ column_name, column_type, null: nullable }) => ({\n            name: column_name,\n            type: getDuckDBType(column_type),\n            nullable: nullable !== \"NO\",\n            databaseType: column_type\n        }));\n    }\n    static async of(sources = {}, config = {}) {\n        const db = await createDuckDB();\n        if (config.query?.castDecimalToDouble === undefined) {\n            config = { ...config, query: { ...config.query, castDecimalToDouble: true } };\n        }\n        if (config.query?.castTimestampToDate === undefined) {\n            config = { ...config, query: { ...config.query, castTimestampToDate: true } };\n        }\n        if (config.query?.castBigIntToDouble === undefined) {\n            config = { ...config, query: { ...config.query, castBigIntToDouble: true } };\n        }\n        await db.open(config);\n        // await registerExtensions(db, config.extensions);\n        await Promise.all(Object.entries(sources).map(([name, source]) => insertSource(db, name, source)));\n        return new DuckDBClient(db);\n    }\n    static sql() {\n        return this.of.apply(this, arguments).then((db) => db.sql.bind(db));\n    }\n}\nObject.defineProperty(DuckDBClient.prototype, \"dialect\", { value: \"duckdb\" });\n// async function registerExtensions(db, extensions) {\n//   const {mainModule} = await bundle;\n//   const platform = Object.keys(bundles).find(\n//     (platform) => mainModule === bundles[platform].mainModule\n//   );\n//   const con = await db.connect();\n//   try {\n//     await Promise.all(\n//       Object.entries(DUCKDB_MANIFEST.extensions).map(([name, {load, [platform]: ref}]) =>\n//         con\n//           .query(`INSTALL \"${name}\" FROM '${import.meta.resolve(ref)}'`)\n//           .then(\n//             () =>\n//               (extensions === undefined ? load : extensions.includes(name)) &&\n//               con.query(`LOAD \"${name}\"`)\n//           )\n//       )\n//     );\n//   } finally {\n//     await con.close();\n//   }\n// }\nasync function insertSource(database, name, source) {\n    source = await source;\n    if (isFileAttachment(source))\n        return insertFile(database, name, source);\n    if (isArrowTable(source))\n        return insertArrowTable(database, name, source);\n    if (Array.isArray(source))\n        return insertArray(database, name, source);\n    if (isArqueroTable(source))\n        return insertArqueroTable(database, name, source);\n    if (typeof source === \"string\")\n        return insertUrl(database, name, source);\n    if (source && typeof source === \"object\") {\n        if (\"data\" in source) {\n            // data + options\n            const { data, ...options } = source;\n            if (isArrowTable(data))\n                return insertArrowTable(database, name, data, options);\n            return insertArray(database, name, data, options);\n        }\n        if (\"file\" in source) {\n            // file + options\n            const { file, ...options } = source;\n            return insertFile(database, name, file, options);\n        }\n    }\n    throw new Error(`invalid source: ${source}`);\n}\nasync function insertUrl(database, name, url) {\n    const connection = await database.connect();\n    try {\n        await connection.query(`CREATE VIEW '${name}' AS FROM '${url}'`);\n    }\n    finally {\n        await connection.close();\n    }\n}\nasync function insertFile(database, name, file, options) {\n    const url = await file.url();\n    if (url.startsWith(\"blob:\")) {\n        const buffer = await file.arrayBuffer();\n        await database.registerFileBuffer(file.name, new Uint8Array(buffer));\n    }\n    else {\n        await database.registerFileURL(file.name, new URL(url, location).href, 4); // duckdb.DuckDBDataProtocol.HTTP\n    }\n    const connection = await database.connect();\n    try {\n        switch (file.mimeType) {\n            case \"text/csv\":\n            case \"text/tab-separated-values\": {\n                return await connection\n                    .insertCSVFromPath(file.name, {\n                    name,\n                    schema: \"main\",\n                    ...options\n                })\n                    .catch(async (error) => {\n                    // If initial attempt to insert CSV resulted in a conversion\n                    // error, try again, this time treating all columns as strings.\n                    if (error.toString().includes(\"Could not convert\")) {\n                        return await insertUntypedCSV(connection, file, name);\n                    }\n                    throw error;\n                });\n            }\n            case \"application/json\":\n                return await connection.insertJSONFromPath(file.name, {\n                    name,\n                    schema: \"main\",\n                    ...options\n                });\n            default:\n                if (/\\.arrow$/i.test(file.name)) {\n                    const buffer = new Uint8Array(await file.arrayBuffer());\n                    return await connection.insertArrowFromIPCStream(buffer, {\n                        name,\n                        schema: \"main\",\n                        ...options\n                    });\n                }\n                if (/\\.parquet$/i.test(file.name)) {\n                    const table = file.size < 50e6 ? \"TABLE\" : \"VIEW\"; // for small files, materialize the table\n                    return await connection.query(`CREATE ${table} '${name}' AS SELECT * FROM parquet_scan('${file.name}')`);\n                }\n                if (/\\.(db|ddb|duckdb)$/i.test(file.name)) {\n                    return await connection.query(`ATTACH '${file.name}' AS ${name} (READ_ONLY)`);\n                }\n                throw new Error(`unknown file type: ${file.mimeType}`);\n        }\n    }\n    finally {\n        await connection.close();\n    }\n}\nasync function insertUntypedCSV(connection, file, name) {\n    const statement = await connection.prepare(`CREATE TABLE '${name}' AS SELECT * FROM read_csv_auto(?, ALL_VARCHAR=TRUE)`);\n    return await statement.send(file.name);\n}\nasync function insertArrowTable(database, name, table, options) {\n    const connection = await database.connect();\n    try {\n        await connection.insertArrowTable(table, {\n            name,\n            schema: \"main\",\n            ...options\n        });\n    }\n    finally {\n        await connection.close();\n    }\n}\nasync function insertArqueroTable(database, name, source) {\n    // TODO When we have stdlib versioning and can upgrade Arquero to version 5,\n    // we can then call source.toArrow() directly, with insertArrowTable()\n    const arrow = await import(\"npm:apache-arrow\");\n    const table = arrow.tableFromIPC(source.toArrowBuffer());\n    return await insertArrowTable(database, name, table);\n}\nasync function insertArray(database, name, array, options) {\n    const arrow = await import(\"npm:apache-arrow\");\n    const table = arrow.tableFromJSON(array);\n    return await insertArrowTable(database, name, table, options);\n}\nasync function createDuckDB() {\n    const { mainWorker, mainModule } = await bundle;\n    const worker = await duckdb.createWorker(mainWorker);\n    const db = new duckdb.AsyncDuckDB(logger, worker);\n    await db.instantiate(mainModule);\n    return db;\n}\n// https://duckdb.org/docs/sql/data_types/overview\nfunction getDuckDBType(type) {\n    switch (type) {\n        case \"BIGINT\":\n        case \"HUGEINT\":\n        case \"UBIGINT\":\n            return \"bigint\";\n        case \"DOUBLE\":\n        case \"REAL\":\n        case \"FLOAT\":\n            return \"number\";\n        case \"INTEGER\":\n        case \"SMALLINT\":\n        case \"TINYINT\":\n        case \"USMALLINT\":\n        case \"UINTEGER\":\n        case \"UTINYINT\":\n            return \"integer\";\n        case \"BOOLEAN\":\n            return \"boolean\";\n        case \"DATE\":\n        case \"TIMESTAMP\":\n        case \"TIMESTAMP WITH TIME ZONE\":\n            return \"date\";\n        case \"VARCHAR\":\n        case \"UUID\":\n            return \"string\";\n        // case \"BLOB\":\n        // case \"INTERVAL\":\n        // case \"TIME\":\n        default:\n            if (/^DECIMAL\\(/.test(type))\n                return \"integer\";\n            return \"other\";\n    }\n}\n// Returns true if the given value is an Observable FileAttachment.\nfunction isFileAttachment(value) {\n    return (value &&\n        typeof value.name === \"string\" &&\n        typeof value.url === \"function\" &&\n        typeof value.arrayBuffer === \"function\");\n}\n// Arquero tables have a `toArrowBuffer` function\nfunction isArqueroTable(value) {\n    return value && typeof value.toArrowBuffer === \"function\";\n}\n// Returns true if the value is an Apache Arrow table. This uses a “duck” test\n// (instead of strict instanceof) because we want it to work with a range of\n// Apache Arrow versions at least 7.0.0 or above.\n// https://arrow.apache.org/docs/7.0/js/classes/Arrow_dom.Table.html\nfunction isArrowTable(value) {\n    return (value &&\n        typeof value.getChild === \"function\" &&\n        typeof value.toArray === \"function\" &&\n        value.schema &&\n        Array.isArray(value.schema.fields));\n}\n"],
  "mappings": "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",
  "names": []
}
