import type { Module } from "@observablehq/runtime";
import { Runtime } from "@observablehq/runtime";
import type { DefineState, Definition } from "./define.js";
import type { observe } from "./display.js";
import { fileAttachments } from "./stdlib/fileAttachment.js";
export type { DefineState, Definition } from "./define.js";
export * from "./display.js";
export * from "./inspect.js";
export * from "./stdlib/index.js";
export type * from "./stdlib/databaseClient.js";
export { DatabaseClient } from "./stdlib/databaseClient.js";
export type * from "./stdlib/fileAttachment.js";
export { FileAttachment, registerFile } from "./stdlib/fileAttachment.js";
export type * from "./stdlib/interpreter.js";
export { Interpreter } from "./stdlib/interpreter.js";
export declare class NotebookRuntime {
    readonly runtime: Runtime & {
        fileAttachments: typeof fileAttachments;
    };
    readonly main: Module;
    constructor(builtins?: {
        aapl: () => Promise<any>;
        alphabet: () => Promise<any>;
        cars: () => Promise<any>;
        citywages: () => Promise<any>;
        diamonds: () => Promise<any>;
        flare: () => Promise<any>;
        industries: () => Promise<any>;
        miserables: () => Promise<any>;
        olympians: () => Promise<any>;
        penguins: () => Promise<any>;
        pizza: () => Promise<any>;
        weather: () => Promise<any>;
        _: () => Promise<any>;
        aq: () => Promise<any>;
        Arrow: () => Promise<any>;
        d3: () => Promise<any>;
        dot: () => Promise<import("./stdlib/template.js").RawTemplateRenderer>;
        duckdb: () => Promise<any>;
        DuckDBClient: () => Promise<typeof import("./stdlib/duckdb.js").DuckDBClient>;
        echarts: () => Promise<any>;
        htl: () => Promise<any>;
        html: () => Promise<any>;
        svg: () => Promise<any>;
        Inputs: () => Promise<typeof import("./stdlib/inputs.js")>;
        L: () => Promise<typeof import("./stdlib/leaflet.js")>;
        mapboxgl: () => Promise<any>;
        md: () => Promise<import("./stdlib/template.js").TemplateRenderer>;
        mermaid: () => Promise<import("./stdlib/template.js").AsyncRawTemplateRenderer>;
        Plot: () => Promise<any>;
        React: () => Promise<any>;
        ReactDOM: () => Promise<any>;
        tex: () => Promise<import("./stdlib/template.js").RawTemplateRenderer & {
            options: (options?: any) => import("./stdlib/template.js").RawTemplateRenderer;
            block: import("./stdlib/template.js").RawTemplateRenderer;
        }>;
        topojson: () => Promise<any>;
        vl: () => Promise<any>;
        now: () => AsyncGenerator<number, void, unknown>;
        width: () => AsyncGenerator<number, void, unknown>;
        DatabaseClient: () => {
            (name: string, options?: import("./stdlib/databaseClient.js").QueryOptionsSpec): import("./stdlib/databaseClient.js").DatabaseClient;
            revive: ({ rows, schema, date, ...meta }: import("../databases/index.js").SerializableQueryResult) => import("./stdlib/databaseClient.js").QueryResult;
            prototype: {
                readonly name: string;
                readonly options: import("./stdlib/databaseClient.js").QueryOptions;
                sql(strings: readonly string[], ...params: import("./stdlib/databaseClient.js").QueryParam[]): Promise<import("./stdlib/databaseClient.js").QueryResult>;
                cachePath(strings: readonly string[], ...params: import("./stdlib/databaseClient.js").QueryParam[]): Promise<string>;
            };
        };
        FileAttachment: () => {
            (name: string, base?: string): import("./stdlib/fileAttachment.js").FileAttachment;
            prototype: {
                href: string;
                name: string;
                mimeType: string;
                lastModified: number | undefined;
                size: number | undefined;
                url(): Promise<string>;
                blob(): Promise<Blob>;
                arrayBuffer(): Promise<ArrayBuffer>;
                text(encoding?: string): Promise<string>;
                json(): Promise<any>;
                stream(): Promise<ReadableStream<Uint8Array<ArrayBufferLike>>>;
                dsv({ delimiter, array, typed }?: {
                    delimiter?: string | undefined;
                    array?: boolean | undefined;
                    typed?: boolean | undefined;
                }): Promise<import("./stdlib/fileAttachment.js").DsvResult>;
                csv(options?: Omit<import("./stdlib/fileAttachment.js").DsvOptions, "delimiter">): Promise<import("./stdlib/fileAttachment.js").DsvResult>;
                tsv(options?: Omit<import("./stdlib/fileAttachment.js").DsvOptions, "delimiter">): Promise<import("./stdlib/fileAttachment.js").DsvResult>;
                image(props?: Partial<HTMLImageElement>): Promise<HTMLImageElement>;
                arrow(): Promise<any>;
                arquero(options?: any): Promise<any>;
                parquet(): Promise<any>;
                xml(mimeType?: DOMParserSupportedType): Promise<Document>;
                html(): Promise<Document>;
            };
        };
        Generators: () => typeof import("./stdlib/generators/index.js");
        Interpreter: () => {
            (name: string, options?: import("./stdlib/interpreter.js").InterpreterOptionsSpec): import("./stdlib/interpreter.js").Interpreter;
            prototype: {
                readonly name: string;
                readonly options: import("./stdlib/interpreter.js").InterpreterOptions;
                run(input: string): Promise<import("./stdlib/fileAttachment.js").FileAttachment>;
                cachePath(input: string): Promise<string>;
            };
        };
        Mutable: () => typeof import("./stdlib/mutable.js").Mutable;
        DOM: () => typeof import("./stdlib/dom/index.js");
        require: () => typeof import("./stdlib/require.js").require;
        __ojs_observer: () => () => import("./stdlib/observer.js").Observer;
    });
    define(state: DefineState, definition: Definition, observer?: typeof observe): void;
}
export declare const runtime: Runtime & {
    fileAttachments: typeof fileAttachments;
};
export declare const main: Module;
export declare const define: (state: DefineState, definition: Definition, observer?: typeof observe) => void;
