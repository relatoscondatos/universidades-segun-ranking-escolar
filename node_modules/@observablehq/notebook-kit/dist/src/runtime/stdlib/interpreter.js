import { nameHash, stringHash } from "../../lib/hash.js";
import { getInterpreterExtension } from "../../lib/interpreters.js";
import { FileAttachment } from "./fileAttachment.js";
export const Interpreter = (name, options) => {
    return new InterpreterImpl(name, normalizeOptions(options));
};
function normalizeOptions({ format = "buffer", id, since } = {}) {
    const options = { format };
    if (id !== undefined)
        options.id = id;
    if (since !== undefined)
        options.since = new Date(since);
    return options;
}
class InterpreterImpl {
    constructor(name, options) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperties(this, {
            name: { value: name, enumerable: true },
            options: { value: options, enumerable: true }
        });
    }
    async run(input) {
        return FileAttachment(await this.cachePath(input));
    }
    async cachePath(input) {
        const { format } = this.options;
        return `.observable/cache/${await nameHash(this.name)}-${await stringHash(input)}${getInterpreterExtension(format)}`; // TODO avoid conflict with database cache?
    }
}
Interpreter.prototype = InterpreterImpl.prototype; // instanceof
Object.defineProperty(InterpreterImpl, "name", { value: "Interpreter" }); // prevent mangling
