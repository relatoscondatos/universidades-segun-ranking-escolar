import { hash, nameHash } from "../../lib/hash.js";
export const DatabaseClient = (name, options) => {
    return new DatabaseClientImpl(name, normalizeOptions(options));
};
function normalizeOptions({ id, since } = {}) {
    const options = {};
    if (id !== undefined)
        options.id = id;
    if (since !== undefined)
        options.since = new Date(since);
    return options;
}
class DatabaseClientImpl {
    constructor(name, options) {
        Object.defineProperty(this, "name", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperties(this, {
            name: { value: name, enumerable: true },
            options: { value: options, enumerable: true }
        });
    }
    async sql(strings, ...params) {
        const path = await this.cachePath(strings, ...params);
        const response = await fetch(path);
        if (!response.ok)
            throw new Error(`failed to fetch: ${path}`);
        return await response.json().then(revive);
    }
    async cachePath(strings, ...params) {
        return `.observable/cache/${await nameHash(this.name)}-${await hash(strings, ...params)}.json`;
    }
}
function revive({ rows, schema, date, ...meta }) {
    for (const column of schema) {
        switch (column.type) {
            case "bigint": {
                const { name } = column;
                for (const row of rows) {
                    const value = row[name];
                    if (value == null)
                        continue;
                    row[name] = Number(value); // TODO BigInt?
                }
                break;
            }
            case "date": {
                const { name } = column;
                for (const row of rows) {
                    const value = row[name];
                    if (value == null)
                        continue;
                    row[name] = asDate(value);
                }
                break;
            }
        }
    }
    if (date != null)
        date = new Date(date);
    return Object.assign(rows, { schema, date }, meta);
}
function asDate(value) {
    return new Date(/^\d{4}-\d{2}-\d{2} \d{2}:\d{2}(?::\d{2})?$/.test(value) ? value + "Z" : value);
}
DatabaseClient.revive = revive;
DatabaseClient.prototype = DatabaseClientImpl.prototype; // instanceof
Object.defineProperty(DatabaseClientImpl, "name", { value: "DatabaseClient" }); // prevent mangling
