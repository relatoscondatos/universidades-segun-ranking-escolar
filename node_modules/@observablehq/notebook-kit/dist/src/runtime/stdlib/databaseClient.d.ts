import type { SerializableQueryResult } from "../../databases/index.js";
/** A serializable value that can be interpolated into a query. */
export type QueryParam = any;
/** @see https://observablehq.com/@observablehq/database-client-specification#%C2%A71 */
export type QueryResult = Record<string, any>[] & {
    schema: ColumnSchema[];
    date: Date;
};
/** @see https://observablehq.com/@observablehq/database-client-specification#%C2%A72.2 */
export interface ColumnSchema {
    /** The name of the column. */
    name: string;
    /** The type of the column. */
    type: "string" | "number" | "integer" | "bigint" | "date" | "boolean" | "object" | "array" | "buffer" | "other";
    /** If present, the nullability of the column is known. */
    nullable?: boolean;
}
export interface QueryOptionsSpec {
    /** if present, the id of the cell that owns this database client */
    id?: number;
    /** if present, results are at least as fresh as the specified date */
    since?: Date | string | number;
}
export interface QueryOptions extends QueryOptionsSpec {
    since?: Date;
}
export interface DatabaseClient {
    readonly name: string;
    readonly options: QueryOptions;
    sql(strings: readonly string[], ...params: QueryParam[]): Promise<QueryResult>;
}
export declare const DatabaseClient: {
    (name: string, options?: QueryOptionsSpec): DatabaseClient;
    revive: typeof revive;
    prototype: DatabaseClientImpl;
};
declare class DatabaseClientImpl implements DatabaseClient {
    readonly name: string;
    readonly options: QueryOptions;
    constructor(name: string, options: QueryOptions);
    sql(strings: readonly string[], ...params: QueryParam[]): Promise<QueryResult>;
    cachePath(strings: readonly string[], ...params: QueryParam[]): Promise<string>;
}
declare function revive({ rows, schema, date, ...meta }: SerializableQueryResult): QueryResult;
export {};
